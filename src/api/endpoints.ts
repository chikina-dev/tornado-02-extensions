/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ArchiveResponse,
  BodyUploadFile,
  BodyUploadFileByUserId,
  CreateAccountResponse,
  DailySummaryResponse,
  EpsonCapabilityRequest,
  EpsonCreateDestinationRequest,
  EpsonPrintFromMarkdownRequest,
  FileBinaryResponse,
  FilesListResponse,
  GetArchiveByDateParams,
  GetLogByDateParams,
  GetProfileParams,
  HTTPValidationError,
  HistoryListResponse,
  HistoryPayload,
  ListFilesByDateParams,
  LogResponse,
  OauthCallbackParams,
  RefreshRequest,
  RefreshResponse,
  RegenerateRequest,
  RootResponse,
  Tag,
  TestEndpointParams,
  TestEndpointResponse,
  TokenResponse,
  UploadFileResponse,
  UploadHistoryResponse,
  UserCreate,
  UserLogin,
  UserProfileActivity,
  WebhookUploadFileResponse
} from './models';

import { customInstance } from './mutator';
/**
 * @summary Create Account
 */
export const createAccount = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CreateAccountResponse>(
      {url: `/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getCreateAccountMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAccount>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAccount>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['createAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAccount>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  createAccount(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof createAccount>>>
    export type CreateAccountMutationBody = UserCreate
    export type CreateAccountMutationError = HTTPValidationError

    /**
 * @summary Create Account
 */
export const useCreateAccount = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAccount>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAccount>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getCreateAccountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Login
 */
export const login = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TokenResponse>(
      {url: `/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = UserLogin
    export type LoginMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLogin = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Refresh Token
 */
export const refreshToken = (
    refreshRequest: RefreshRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RefreshResponse>(
      {url: `/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshRequest, signal
    },
      );
    }
  


export const getRefreshTokenMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: RefreshRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: RefreshRequest}, TContext> => {

const mutationKey = ['refreshToken'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, {data: RefreshRequest}> = (props) => {
          const {data} = props ?? {};

          return  refreshToken(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>
    export type RefreshTokenMutationBody = RefreshRequest
    export type RefreshTokenMutationError = HTTPValidationError

    /**
 * @summary Refresh Token
 */
export const useRefreshToken = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: RefreshRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshToken>>,
        TError,
        {data: RefreshRequest},
        TContext
      > => {

      const mutationOptions = getRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Logout
 */
export const logout = (
    refreshRequest: RefreshRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/logout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshRequest, signal
    },
      );
    }
  


export const getLogoutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{data: RefreshRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{data: RefreshRequest}, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, {data: RefreshRequest}> = (props) => {
          const {data} = props ?? {};

          return  logout(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    export type LogoutMutationBody = RefreshRequest
    export type LogoutMutationError = HTTPValidationError

    /**
 * @summary Logout
 */
export const useLogout = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{data: RefreshRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        {data: RefreshRequest},
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get Profile
 */
export const getProfile = (
    params?: GetProfileParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserProfileActivity>(
      {url: `/profile`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetProfileQueryKey = (params?: GetProfileParams,) => {
    return [`/profile`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof getProfile>>, TError = HTTPValidationError>(params?: GetProfileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) => getProfile(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>
export type GetProfileQueryError = HTTPValidationError


export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = HTTPValidationError>(
 params: undefined |  GetProfileParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = HTTPValidationError>(
 params?: GetProfileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = HTTPValidationError>(
 params?: GetProfileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Profile
 */

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = HTTPValidationError>(
 params?: GetProfileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Upload File
 */
export const uploadFile = (
    bodyUploadFile: BodyUploadFile,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadFile.file)

      return customInstance<UploadFileResponse>(
      {url: `/upload/file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadFileMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFile>>, TError,{data: BodyUploadFile}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadFile>>, TError,{data: BodyUploadFile}, TContext> => {

const mutationKey = ['uploadFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadFile>>, {data: BodyUploadFile}> = (props) => {
          const {data} = props ?? {};

          return  uploadFile(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFile>>>
    export type UploadFileMutationBody = BodyUploadFile
    export type UploadFileMutationError = HTTPValidationError

    /**
 * @summary Upload File
 */
export const useUploadFile = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFile>>, TError,{data: BodyUploadFile}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadFile>>,
        TError,
        {data: BodyUploadFile},
        TContext
      > => {

      const mutationOptions = getUploadFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Upload History
 */
export const uploadHistory = (
    historyPayload: HistoryPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UploadHistoryResponse>(
      {url: `/upload/history`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: historyPayload, signal
    },
      );
    }
  


export const getUploadHistoryMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadHistory>>, TError,{data: HistoryPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadHistory>>, TError,{data: HistoryPayload}, TContext> => {

const mutationKey = ['uploadHistory'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadHistory>>, {data: HistoryPayload}> = (props) => {
          const {data} = props ?? {};

          return  uploadHistory(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof uploadHistory>>>
    export type UploadHistoryMutationBody = HistoryPayload
    export type UploadHistoryMutationError = HTTPValidationError

    /**
 * @summary Upload History
 */
export const useUploadHistory = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadHistory>>, TError,{data: HistoryPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadHistory>>,
        TError,
        {data: HistoryPayload},
        TContext
      > => {

      const mutationOptions = getUploadHistoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Webhook File Upload
 */
export const uploadFileByUserId = (
    userId: number,
    bodyUploadFileByUserId: BodyUploadFileByUserId,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadFileByUserId.file)

      return customInstance<WebhookUploadFileResponse>(
      {url: `/upload/file/${userId}`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadFileByUserIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFileByUserId>>, TError,{userId: number;data: BodyUploadFileByUserId}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadFileByUserId>>, TError,{userId: number;data: BodyUploadFileByUserId}, TContext> => {

const mutationKey = ['uploadFileByUserId'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadFileByUserId>>, {userId: number;data: BodyUploadFileByUserId}> = (props) => {
          const {userId,data} = props ?? {};

          return  uploadFileByUserId(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadFileByUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFileByUserId>>>
    export type UploadFileByUserIdMutationBody = BodyUploadFileByUserId
    export type UploadFileByUserIdMutationError = HTTPValidationError

    /**
 * @summary Webhook File Upload
 */
export const useUploadFileByUserId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFileByUserId>>, TError,{userId: number;data: BodyUploadFileByUserId}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadFileByUserId>>,
        TError,
        {userId: number;data: BodyUploadFileByUserId},
        TContext
      > => {

      const mutationOptions = getUploadFileByUserIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List Files
 */
export const listFilesByDate = (
    params?: ListFilesByDateParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FilesListResponse>(
      {url: `/files`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getListFilesByDateQueryKey = (params?: ListFilesByDateParams,) => {
    return [`/files`, ...(params ? [params]: [])] as const;
    }

    
export const getListFilesByDateQueryOptions = <TData = Awaited<ReturnType<typeof listFilesByDate>>, TError = HTTPValidationError>(params?: ListFilesByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFilesByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListFilesByDateQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listFilesByDate>>> = ({ signal }) => listFilesByDate(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listFilesByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListFilesByDateQueryResult = NonNullable<Awaited<ReturnType<typeof listFilesByDate>>>
export type ListFilesByDateQueryError = HTTPValidationError


export function useListFilesByDate<TData = Awaited<ReturnType<typeof listFilesByDate>>, TError = HTTPValidationError>(
 params: undefined |  ListFilesByDateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFilesByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFilesByDate>>,
          TError,
          Awaited<ReturnType<typeof listFilesByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListFilesByDate<TData = Awaited<ReturnType<typeof listFilesByDate>>, TError = HTTPValidationError>(
 params?: ListFilesByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFilesByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFilesByDate>>,
          TError,
          Awaited<ReturnType<typeof listFilesByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListFilesByDate<TData = Awaited<ReturnType<typeof listFilesByDate>>, TError = HTTPValidationError>(
 params?: ListFilesByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFilesByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Files
 */

export function useListFilesByDate<TData = Awaited<ReturnType<typeof listFilesByDate>>, TError = HTTPValidationError>(
 params?: ListFilesByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listFilesByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListFilesByDateQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary View File
 */
export const getFileById = (
    fileId: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FileBinaryResponse>(
      {url: `/file/${fileId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetFileByIdQueryKey = (fileId?: number,) => {
    return [`/file/${fileId}`] as const;
    }

    
export const getGetFileByIdQueryOptions = <TData = Awaited<ReturnType<typeof getFileById>>, TError = HTTPValidationError>(fileId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdQueryError = HTTPValidationError


export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = HTTPValidationError>(
 fileId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          Awaited<ReturnType<typeof getFileById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = HTTPValidationError>(
 fileId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          Awaited<ReturnType<typeof getFileById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = HTTPValidationError>(
 fileId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary View File
 */

export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = HTTPValidationError>(
 fileId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileByIdQueryOptions(fileId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary View History
 */
export const listHistoryByDate = (
    date: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<HistoryListResponse>(
      {url: `/history/${date}`, method: 'GET', signal
    },
      );
    }
  

export const getListHistoryByDateQueryKey = (date?: string,) => {
    return [`/history/${date}`] as const;
    }

    
export const getListHistoryByDateQueryOptions = <TData = Awaited<ReturnType<typeof listHistoryByDate>>, TError = HTTPValidationError>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHistoryByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListHistoryByDateQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listHistoryByDate>>> = ({ signal }) => listHistoryByDate(date, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listHistoryByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListHistoryByDateQueryResult = NonNullable<Awaited<ReturnType<typeof listHistoryByDate>>>
export type ListHistoryByDateQueryError = HTTPValidationError


export function useListHistoryByDate<TData = Awaited<ReturnType<typeof listHistoryByDate>>, TError = HTTPValidationError>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHistoryByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listHistoryByDate>>,
          TError,
          Awaited<ReturnType<typeof listHistoryByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListHistoryByDate<TData = Awaited<ReturnType<typeof listHistoryByDate>>, TError = HTTPValidationError>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHistoryByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listHistoryByDate>>,
          TError,
          Awaited<ReturnType<typeof listHistoryByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListHistoryByDate<TData = Awaited<ReturnType<typeof listHistoryByDate>>, TError = HTTPValidationError>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHistoryByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary View History
 */

export function useListHistoryByDate<TData = Awaited<ReturnType<typeof listHistoryByDate>>, TError = HTTPValidationError>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listHistoryByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListHistoryByDateQueryOptions(date,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Log
 */
export const getLogByDate = (
    date: string,
    params?: GetLogByDateParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<LogResponse>(
      {url: `/log/${date}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetLogByDateQueryKey = (date?: string,
    params?: GetLogByDateParams,) => {
    return [`/log/${date}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLogByDateQueryOptions = <TData = Awaited<ReturnType<typeof getLogByDate>>, TError = HTTPValidationError>(date: string,
    params?: GetLogByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLogByDateQueryKey(date,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogByDate>>> = ({ signal }) => getLogByDate(date,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLogByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLogByDateQueryResult = NonNullable<Awaited<ReturnType<typeof getLogByDate>>>
export type GetLogByDateQueryError = HTTPValidationError


export function useGetLogByDate<TData = Awaited<ReturnType<typeof getLogByDate>>, TError = HTTPValidationError>(
 date: string,
    params: undefined |  GetLogByDateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogByDate>>,
          TError,
          Awaited<ReturnType<typeof getLogByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLogByDate<TData = Awaited<ReturnType<typeof getLogByDate>>, TError = HTTPValidationError>(
 date: string,
    params?: GetLogByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogByDate>>,
          TError,
          Awaited<ReturnType<typeof getLogByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLogByDate<TData = Awaited<ReturnType<typeof getLogByDate>>, TError = HTTPValidationError>(
 date: string,
    params?: GetLogByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Log
 */

export function useGetLogByDate<TData = Awaited<ReturnType<typeof getLogByDate>>, TError = HTTPValidationError>(
 date: string,
    params?: GetLogByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLogByDateQueryOptions(date,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Archive
 */
export const getArchiveByDate = (
    date: string,
    params?: GetArchiveByDateParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ArchiveResponse>(
      {url: `/archive/${date}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetArchiveByDateQueryKey = (date?: string,
    params?: GetArchiveByDateParams,) => {
    return [`/archive/${date}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetArchiveByDateQueryOptions = <TData = Awaited<ReturnType<typeof getArchiveByDate>>, TError = HTTPValidationError>(date: string,
    params?: GetArchiveByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArchiveByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArchiveByDateQueryKey(date,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArchiveByDate>>> = ({ signal }) => getArchiveByDate(date,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getArchiveByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetArchiveByDateQueryResult = NonNullable<Awaited<ReturnType<typeof getArchiveByDate>>>
export type GetArchiveByDateQueryError = HTTPValidationError


export function useGetArchiveByDate<TData = Awaited<ReturnType<typeof getArchiveByDate>>, TError = HTTPValidationError>(
 date: string,
    params: undefined |  GetArchiveByDateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArchiveByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArchiveByDate>>,
          TError,
          Awaited<ReturnType<typeof getArchiveByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetArchiveByDate<TData = Awaited<ReturnType<typeof getArchiveByDate>>, TError = HTTPValidationError>(
 date: string,
    params?: GetArchiveByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArchiveByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArchiveByDate>>,
          TError,
          Awaited<ReturnType<typeof getArchiveByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetArchiveByDate<TData = Awaited<ReturnType<typeof getArchiveByDate>>, TError = HTTPValidationError>(
 date: string,
    params?: GetArchiveByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArchiveByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Archive
 */

export function useGetArchiveByDate<TData = Awaited<ReturnType<typeof getArchiveByDate>>, TError = HTTPValidationError>(
 date: string,
    params?: GetArchiveByDateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArchiveByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetArchiveByDateQueryOptions(date,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Test Endpoint
 */
export const testEndpoint = (
    params?: TestEndpointParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TestEndpointResponse>(
      {url: `/test`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getTestEndpointQueryKey = (params?: TestEndpointParams,) => {
    return [`/test`, ...(params ? [params]: [])] as const;
    }

    
export const getTestEndpointQueryOptions = <TData = Awaited<ReturnType<typeof testEndpoint>>, TError = HTTPValidationError>(params?: TestEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEndpoint>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestEndpointQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testEndpoint>>> = ({ signal }) => testEndpoint(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof testEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof testEndpoint>>>
export type TestEndpointQueryError = HTTPValidationError


export function useTestEndpoint<TData = Awaited<ReturnType<typeof testEndpoint>>, TError = HTTPValidationError>(
 params: undefined |  TestEndpointParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testEndpoint>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestEndpoint<TData = Awaited<ReturnType<typeof testEndpoint>>, TError = HTTPValidationError>(
 params?: TestEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testEndpoint>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestEndpoint<TData = Awaited<ReturnType<typeof testEndpoint>>, TError = HTTPValidationError>(
 params?: TestEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEndpoint>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Test Endpoint
 */

export function useTestEndpoint<TData = Awaited<ReturnType<typeof testEndpoint>>, TError = HTTPValidationError>(
 params?: TestEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEndpoint>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestEndpointQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Tags
 */
export const listTags = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<Tag[]>(
      {url: `/tags/`, method: 'GET', signal
    },
      );
    }
  

export const getListTagsQueryKey = () => {
    return [`/tags/`] as const;
    }

    
export const getListTagsQueryOptions = <TData = Awaited<ReturnType<typeof listTags>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTags>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTags>>> = ({ signal }) => listTags(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTagsQueryResult = NonNullable<Awaited<ReturnType<typeof listTags>>>
export type ListTagsQueryError = unknown


export function useListTags<TData = Awaited<ReturnType<typeof listTags>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTags>>,
          TError,
          Awaited<ReturnType<typeof listTags>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTags<TData = Awaited<ReturnType<typeof listTags>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTags>>,
          TError,
          Awaited<ReturnType<typeof listTags>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTags<TData = Awaited<ReturnType<typeof listTags>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTags>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Tags
 */

export function useListTags<TData = Awaited<ReturnType<typeof listTags>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTags>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTagsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Tags For Search History
 */
export const listTagsForSearchHistory = (
    searchHistoryId: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Tag[]>(
      {url: `/tags/search_history/${searchHistoryId}`, method: 'GET', signal
    },
      );
    }
  

export const getListTagsForSearchHistoryQueryKey = (searchHistoryId?: number,) => {
    return [`/tags/search_history/${searchHistoryId}`] as const;
    }

    
export const getListTagsForSearchHistoryQueryOptions = <TData = Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError = HTTPValidationError>(searchHistoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTagsForSearchHistoryQueryKey(searchHistoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTagsForSearchHistory>>> = ({ signal }) => listTagsForSearchHistory(searchHistoryId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(searchHistoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTagsForSearchHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof listTagsForSearchHistory>>>
export type ListTagsForSearchHistoryQueryError = HTTPValidationError


export function useListTagsForSearchHistory<TData = Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError = HTTPValidationError>(
 searchHistoryId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTagsForSearchHistory>>,
          TError,
          Awaited<ReturnType<typeof listTagsForSearchHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTagsForSearchHistory<TData = Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError = HTTPValidationError>(
 searchHistoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTagsForSearchHistory>>,
          TError,
          Awaited<ReturnType<typeof listTagsForSearchHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTagsForSearchHistory<TData = Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError = HTTPValidationError>(
 searchHistoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Tags For Search History
 */

export function useListTagsForSearchHistory<TData = Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError = HTTPValidationError>(
 searchHistoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForSearchHistory>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTagsForSearchHistoryQueryOptions(searchHistoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Tags For Daily
 */
export const listTagsForDaily = (
    date: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Tag[]>(
      {url: `/tags/daily/${date}`, method: 'GET', signal
    },
      );
    }
  

export const getListTagsForDailyQueryKey = (date?: string,) => {
    return [`/tags/daily/${date}`] as const;
    }

    
export const getListTagsForDailyQueryOptions = <TData = Awaited<ReturnType<typeof listTagsForDaily>>, TError = HTTPValidationError>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForDaily>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTagsForDailyQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTagsForDaily>>> = ({ signal }) => listTagsForDaily(date, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTagsForDaily>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTagsForDailyQueryResult = NonNullable<Awaited<ReturnType<typeof listTagsForDaily>>>
export type ListTagsForDailyQueryError = HTTPValidationError


export function useListTagsForDaily<TData = Awaited<ReturnType<typeof listTagsForDaily>>, TError = HTTPValidationError>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForDaily>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTagsForDaily>>,
          TError,
          Awaited<ReturnType<typeof listTagsForDaily>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTagsForDaily<TData = Awaited<ReturnType<typeof listTagsForDaily>>, TError = HTTPValidationError>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForDaily>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTagsForDaily>>,
          TError,
          Awaited<ReturnType<typeof listTagsForDaily>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTagsForDaily<TData = Awaited<ReturnType<typeof listTagsForDaily>>, TError = HTTPValidationError>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForDaily>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Tags For Daily
 */

export function useListTagsForDaily<TData = Awaited<ReturnType<typeof listTagsForDaily>>, TError = HTTPValidationError>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTagsForDaily>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTagsForDailyQueryOptions(date,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Daily Summary By Md
 */
export const getDailySummaryByDate = (
    year: number,
    month: number,
    day: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailySummaryResponse>(
      {url: `/summaries/${year}/${month}/${day}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDailySummaryByDateQueryKey = (year?: number,
    month?: number,
    day?: number,) => {
    return [`/summaries/${year}/${month}/${day}`] as const;
    }

    
export const getGetDailySummaryByDateQueryOptions = <TData = Awaited<ReturnType<typeof getDailySummaryByDate>>, TError = HTTPValidationError>(year: number,
    month: number,
    day: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailySummaryByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailySummaryByDateQueryKey(year,month,day);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailySummaryByDate>>> = ({ signal }) => getDailySummaryByDate(year,month,day, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(year && month && day), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailySummaryByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailySummaryByDateQueryResult = NonNullable<Awaited<ReturnType<typeof getDailySummaryByDate>>>
export type GetDailySummaryByDateQueryError = HTTPValidationError


export function useGetDailySummaryByDate<TData = Awaited<ReturnType<typeof getDailySummaryByDate>>, TError = HTTPValidationError>(
 year: number,
    month: number,
    day: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailySummaryByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailySummaryByDate>>,
          TError,
          Awaited<ReturnType<typeof getDailySummaryByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailySummaryByDate<TData = Awaited<ReturnType<typeof getDailySummaryByDate>>, TError = HTTPValidationError>(
 year: number,
    month: number,
    day: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailySummaryByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailySummaryByDate>>,
          TError,
          Awaited<ReturnType<typeof getDailySummaryByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailySummaryByDate<TData = Awaited<ReturnType<typeof getDailySummaryByDate>>, TError = HTTPValidationError>(
 year: number,
    month: number,
    day: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailySummaryByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Daily Summary By Md
 */

export function useGetDailySummaryByDate<TData = Awaited<ReturnType<typeof getDailySummaryByDate>>, TError = HTTPValidationError>(
 year: number,
    month: number,
    day: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailySummaryByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailySummaryByDateQueryOptions(year,month,day,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Admin Regenerate
 */
export const adminRegenerate = (
    regenerateRequest: RegenerateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/admin/regenerate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: regenerateRequest, signal
    },
      );
    }
  


export const getAdminRegenerateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRegenerate>>, TError,{data: RegenerateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminRegenerate>>, TError,{data: RegenerateRequest}, TContext> => {

const mutationKey = ['adminRegenerate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminRegenerate>>, {data: RegenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  adminRegenerate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminRegenerateMutationResult = NonNullable<Awaited<ReturnType<typeof adminRegenerate>>>
    export type AdminRegenerateMutationBody = RegenerateRequest
    export type AdminRegenerateMutationError = HTTPValidationError

    /**
 * @summary Admin Regenerate
 */
export const useAdminRegenerate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminRegenerate>>, TError,{data: RegenerateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminRegenerate>>,
        TError,
        {data: RegenerateRequest},
        TContext
      > => {

      const mutationOptions = getAdminRegenerateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Admin Eps Capability
 */
export const adminEpsonCapability = (
    epsonCapabilityRequest: EpsonCapabilityRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/admin/epson/capability`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: epsonCapabilityRequest, signal
    },
      );
    }
  


export const getAdminEpsonCapabilityMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminEpsonCapability>>, TError,{data: EpsonCapabilityRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminEpsonCapability>>, TError,{data: EpsonCapabilityRequest}, TContext> => {

const mutationKey = ['adminEpsonCapability'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminEpsonCapability>>, {data: EpsonCapabilityRequest}> = (props) => {
          const {data} = props ?? {};

          return  adminEpsonCapability(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminEpsonCapabilityMutationResult = NonNullable<Awaited<ReturnType<typeof adminEpsonCapability>>>
    export type AdminEpsonCapabilityMutationBody = EpsonCapabilityRequest
    export type AdminEpsonCapabilityMutationError = HTTPValidationError

    /**
 * @summary Admin Eps Capability
 */
export const useAdminEpsonCapability = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminEpsonCapability>>, TError,{data: EpsonCapabilityRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminEpsonCapability>>,
        TError,
        {data: EpsonCapabilityRequest},
        TContext
      > => {

      const mutationOptions = getAdminEpsonCapabilityMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Admin Eps Create Destination
 */
export const adminEpsonCreateDestination = (
    epsonCreateDestinationRequest: EpsonCreateDestinationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/admin/epson/scan-destination`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: epsonCreateDestinationRequest, signal
    },
      );
    }
  


export const getAdminEpsonCreateDestinationMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminEpsonCreateDestination>>, TError,{data: EpsonCreateDestinationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminEpsonCreateDestination>>, TError,{data: EpsonCreateDestinationRequest}, TContext> => {

const mutationKey = ['adminEpsonCreateDestination'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminEpsonCreateDestination>>, {data: EpsonCreateDestinationRequest}> = (props) => {
          const {data} = props ?? {};

          return  adminEpsonCreateDestination(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminEpsonCreateDestinationMutationResult = NonNullable<Awaited<ReturnType<typeof adminEpsonCreateDestination>>>
    export type AdminEpsonCreateDestinationMutationBody = EpsonCreateDestinationRequest
    export type AdminEpsonCreateDestinationMutationError = HTTPValidationError

    /**
 * @summary Admin Eps Create Destination
 */
export const useAdminEpsonCreateDestination = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminEpsonCreateDestination>>, TError,{data: EpsonCreateDestinationRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminEpsonCreateDestination>>,
        TError,
        {data: EpsonCreateDestinationRequest},
        TContext
      > => {

      const mutationOptions = getAdminEpsonCreateDestinationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Admin Eps Print From Md
 */
export const adminEpsonPrintFromMarkdown = (
    epsonPrintFromMarkdownRequest: EpsonPrintFromMarkdownRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/admin/epson/print`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: epsonPrintFromMarkdownRequest, signal
    },
      );
    }
  


export const getAdminEpsonPrintFromMarkdownMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminEpsonPrintFromMarkdown>>, TError,{data: EpsonPrintFromMarkdownRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminEpsonPrintFromMarkdown>>, TError,{data: EpsonPrintFromMarkdownRequest}, TContext> => {

const mutationKey = ['adminEpsonPrintFromMarkdown'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminEpsonPrintFromMarkdown>>, {data: EpsonPrintFromMarkdownRequest}> = (props) => {
          const {data} = props ?? {};

          return  adminEpsonPrintFromMarkdown(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminEpsonPrintFromMarkdownMutationResult = NonNullable<Awaited<ReturnType<typeof adminEpsonPrintFromMarkdown>>>
    export type AdminEpsonPrintFromMarkdownMutationBody = EpsonPrintFromMarkdownRequest
    export type AdminEpsonPrintFromMarkdownMutationError = HTTPValidationError

    /**
 * @summary Admin Eps Print From Md
 */
export const useAdminEpsonPrintFromMarkdown = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminEpsonPrintFromMarkdown>>, TError,{data: EpsonPrintFromMarkdownRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminEpsonPrintFromMarkdown>>,
        TError,
        {data: EpsonPrintFromMarkdownRequest},
        TContext
      > => {

      const mutationOptions = getAdminEpsonPrintFromMarkdownMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Optional helper to initiate the OAuth 2.0 Authorization Code + PKCE flow.
Reads provider settings from env vars and redirects to the provider's authorize URL.

Env vars:
  - OAUTH_AUTHORIZATION_URL (required)
  - OAUTH_CLIENT_ID (required)
  - OAUTH_SCOPE (space-separated, optional)
  - OAUTH_REDIRECT_URI (optional; defaults to this API's /oauth/callback)
  - OAUTH_EXTRA_PARAMS (optional JSON of extra query params e.g. {"audience":"..."})
 * @summary Oauth Start
 */
export const oauthStart = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/oauth/start`, method: 'GET', signal
    },
      );
    }
  

export const getOauthStartQueryKey = () => {
    return [`/oauth/start`] as const;
    }

    
export const getOauthStartQueryOptions = <TData = Awaited<ReturnType<typeof oauthStart>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthStart>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthStartQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthStart>>> = ({ signal }) => oauthStart(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthStart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OauthStartQueryResult = NonNullable<Awaited<ReturnType<typeof oauthStart>>>
export type OauthStartQueryError = unknown


export function useOauthStart<TData = Awaited<ReturnType<typeof oauthStart>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthStart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthStart>>,
          TError,
          Awaited<ReturnType<typeof oauthStart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthStart<TData = Awaited<ReturnType<typeof oauthStart>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthStart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthStart>>,
          TError,
          Awaited<ReturnType<typeof oauthStart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthStart<TData = Awaited<ReturnType<typeof oauthStart>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthStart>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Oauth Start
 */

export function useOauthStart<TData = Awaited<ReturnType<typeof oauthStart>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthStart>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOauthStartQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * OAuth 2.0 redirect (callback) endpoint. Validates state and forwards
result to a configured frontend callback URL, or returns JSON/HTML.
 * @summary Oauth Callback
 */
export const oauthCallback = (
    params?: OauthCallbackParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/oauth/callback`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getOauthCallbackQueryKey = (params?: OauthCallbackParams,) => {
    return [`/oauth/callback`, ...(params ? [params]: [])] as const;
    }

    
export const getOauthCallbackQueryOptions = <TData = Awaited<ReturnType<typeof oauthCallback>>, TError = HTTPValidationError>(params?: OauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthCallback>>> = ({ signal }) => oauthCallback(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OauthCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof oauthCallback>>>
export type OauthCallbackQueryError = HTTPValidationError


export function useOauthCallback<TData = Awaited<ReturnType<typeof oauthCallback>>, TError = HTTPValidationError>(
 params: undefined |  OauthCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthCallback>>,
          TError,
          Awaited<ReturnType<typeof oauthCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthCallback<TData = Awaited<ReturnType<typeof oauthCallback>>, TError = HTTPValidationError>(
 params?: OauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthCallback>>,
          TError,
          Awaited<ReturnType<typeof oauthCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthCallback<TData = Awaited<ReturnType<typeof oauthCallback>>, TError = HTTPValidationError>(
 params?: OauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Oauth Callback
 */

export function useOauthCallback<TData = Awaited<ReturnType<typeof oauthCallback>>, TError = HTTPValidationError>(
 params?: OauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOauthCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Root
 */
export const rootIndex = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<RootResponse>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getRootIndexQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootIndexQueryOptions = <TData = Awaited<ReturnType<typeof rootIndex>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootIndex>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootIndexQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootIndex>>> = ({ signal }) => rootIndex(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootIndex>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootIndexQueryResult = NonNullable<Awaited<ReturnType<typeof rootIndex>>>
export type RootIndexQueryError = unknown


export function useRootIndex<TData = Awaited<ReturnType<typeof rootIndex>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootIndex>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootIndex>>,
          TError,
          Awaited<ReturnType<typeof rootIndex>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootIndex<TData = Awaited<ReturnType<typeof rootIndex>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootIndex>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootIndex>>,
          TError,
          Awaited<ReturnType<typeof rootIndex>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootIndex<TData = Awaited<ReturnType<typeof rootIndex>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootIndex>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootIndex<TData = Awaited<ReturnType<typeof rootIndex>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootIndex>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootIndexQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
